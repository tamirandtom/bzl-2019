<html lang="en">

<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>

<body>
	<style>
		body {
			background-image: linear-gradient(180deg, #FF0A19 0%, #FFBA01 100%);
			padding: 0px;
			margin: 0px;
		}
		canvas {
			filter: blur(4px);
		}
		#loading {
			position: absolute;
			top:0px;
			left: 0px;
			width: 100%;
			height: 100%;
			color:#fff;
			font-size: 40px;
			font-family: Arial, Helvetica, sans-serif;
			line-height: 80vh;
			text-align: center;
			justify-content: center;
			z-index: 999;
			opacity: 1;
			transition: all 0.3s linear;

		}
		#loading.hide {
			opacity: 0;
		}
	</style>
	<div id="loading"> </div>
	<script type="module">
		import * as THREE from './three.module.js';
		import { OBJLoader } from './obj.js';
		import { CinematicCamera } from './camera.js';




		function updateText(n) {
			document.getElementById("loading").innerHTML = ""+n+"%";


		}
		var container;

		var canvas;


		var camera, scene, renderer;
		var mouseX = 0, mouseY = 0;
		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;
		var object;



		init();
		animate();
		function init() {
			container = document.createElement('div');
			document.body.appendChild(container);


			var effectController = {
					focalLength: 15,
					// jsDepthCalculation: true,
					// shaderFocus: false,
					//
					fstop: 1.8,
					// maxblur: 1.0,
					//
					showFocus: false,
					focalDepth: 5,
					// manualdof: false,
					// vigne tting: true,
					// depthblur: true,
					//
					// threshold: 0.5,
					// gain: 2.0,
					// bias: 0.5,
					fringe: 0.7,
					//
					focalLength: 35,
					// noise: true,
					// pentagon: false,
					//
					// dithering: 0.0001
				};


			// camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);


			camera = new CinematicCamera( 90, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.setLens( 5 );


			camera.position.z = 300;


			for ( var e in effectController ) {
						if ( e in camera.postprocessing.bokeh_uniforms ) {
							camera.postprocessing.bokeh_uniforms[ e ].value = effectController[ e ];
						}
					}
					camera.postprocessing.bokeh_uniforms[ 'znear' ].value = camera.near;
					camera.postprocessing.bokeh_uniforms[ 'zfar' ].value = camera.far;
					camera.setLens( effectController.focalLength, camera.frameHeight, effectController.fstop, camera.coc );
					effectController[ 'focalDepth' ] = camera.postprocessing.bokeh_uniforms[ 'focalDepth' ].value;

			// scene
			scene = new THREE.Scene();
			var ambientLight = new THREE.AmbientLight(0xccbbbb, 0.2);
			scene.add(ambientLight);
			
			var pointLight = new THREE.PointLight(0xffffff, 1);
			pointLight.position.set( 0, 200, 200 )
			scene.add(pointLight);


				
			var pointLight2 = new THREE.PointLight(0xffaa00, 1);
			pointLight2.position.set( 500, 0, 100 )
			scene.add(pointLight2);



			scene.add(camera);
			// Cloth texture
			var textureLoader = new THREE.TextureLoader(manager);
			var texture = textureLoader.load('t.png');
			texture.repeat.set(1, 1);

			var clothTexture = new THREE.MeshPhongMaterial({ map: texture, specular: 0xffffff, emissive: 0x111200, shininess: 0, flatShading: false });



			//Face texture

			var faceTexture = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff, emissive: 0x221100, shininess: 5, flatShading: false });
			//Glasses texture

			var GlassesTexture = new THREE.MeshPhongMaterial({ color: 0x222222, specular: 0xaaaaaa, shininess: 1, flatShading: false });

			function loadModel() {

				object.traverse(function (child) {
					// console.log(child.name);
					if (child.name == "Polygon") {
						// Skarf texture
						child.material = clothTexture;
						child.geometry.computeFaceNormals()
						child.geometry.computeVertexNormals();
					}
					else if (child.name == "<STL_BINARY>_2.1") {
						// Person texture
						child.geometry.computeFaceNormals()
						child.geometry.computeVertexNormals();
						child.material = faceTexture;

					} else {
						// VR texture
						child.material = GlassesTexture;

					}
				});
				object.position.x = 22;
				object.position.y = 65;
				object.position.z = 0;
				object.rotation.y = -9.5;
				object.scale.y = 3.8;
				object.scale.x = 3.8;
				object.scale.z = 3.8;
				scene.add(object);
			}
			var manager = new THREE.LoadingManager(loadModel);
			// manager.onProgress = function (item, loaded, total) {
			// 	// console.log(item, loaded, total);
			// };

			// model
			function onProgress(xhr) {
				if (xhr.lengthComputable) {
					var percentComplete = xhr.loaded / xhr.total * 100;
					console.log('model ' +  + '% downloaded');
					updateText(Math.round(percentComplete, 2));
				}
			}
			function onError() { }
			var loader = new OBJLoader(manager);
			loader.load('o.obj', function (obj) {
				object = obj;
			document.getElementById("loading").classList.add("hide");
			}, onProgress, onError);
			renderer = new THREE.WebGLRenderer({ alpha: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0x000000, 0.0);
			container.appendChild(renderer.domElement);
			document.addEventListener('mousemove', onDocumentMouseMove, false);
			window.addEventListener('resize', onWindowResize, false);
		}
		function onWindowResize() {
			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}
		function onDocumentMouseMove(event) {
			mouseX = (event.clientX - windowHalfX) / 2;
			mouseY = (event.clientY - windowHalfY) / 2;
		}
		//
		function animate() {
			requestAnimationFrame(animate);
			render();
		}
		function render() {
			camera.position.x += (- mouseX - camera.position.x) * .02;
			camera.position.y += (mouseY - camera.position.y) * .01;
			camera.lookAt(scene.position);
			// if ( camera.postprocessing.enabled ) {
			// 		camera.renderCinematic( scene, renderer );
			// 	} else {
					scene.overrideMaterial = null;
					renderer.clear();
					renderer.render( scene, camera );
				// }
		}


	</script>

</body>

</html>